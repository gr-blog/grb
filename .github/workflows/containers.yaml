name: Build & publish container images and manifests

on:
  push:
    branches: [main]
  workflow_dispatch:
# Grant the job permission to write packages
permissions:
  contents: read # needed by checkout
  packages: write # lets us push to ghcr.io
env:
  REGISTRY: ghcr.io
  IMAGE_OWNER: ${{ github.repository_owner }}

jobs:
  # --------------------------------------------------
  # 0. Detect what actually changed in this push
  # --------------------------------------------------
  changes:
    name: Detect changed paths
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.filter.outputs.api }}
      frontend: ${{ steps.filter.outputs.frontend }}
      bot: ${{ steps.filter.outputs.bot }}
    steps:
      - uses: actions/checkout@v4

      - id: filter
        uses: dorny/paths-filter@v3
        with:
          base: ${{ github.event.before }} # compare against the previous commit
          filters: |
            # Shared bits ─ identical to *paths_shared in GitLab CI
            _shared:
              - packages/k8s/src/shared/**/*
              - packages/k8s/src/main.ts
              - packages/tsconfig.base.json
              - packages/k8s/*.sh
              - build-target.sh
              - manifest.sh
              - Dockerfile
            # Service-specific filters include the shared group
            api:
              - *_shared
              - packages/k8s/src/api/**/*
              - packages/api/**/*
            frontend:
              - *_shared
              - packages/k8s/src/frontend/**/*
              - packages/frontend/**/*
            bot:
              - *_shared
              - packages/k8s/src/bot/**/*
              - packages/bot/**/*

  # --------------------------------------------------
  # 1. Build & push the per-arch images
  # --------------------------------------------------
  image:
    name: push ${{ matrix.service }} image
    runs-on: ubuntu-latest
    needs: changes
    container: moby/buildkit:latest
    strategy:
      matrix:
        service: [api, frontend, bot]
    env:
      SERVICE: ${{ matrix.service }}

    # run only if the relevant service (or its shared parts) changed
    if: |
      (matrix.service == 'api' && needs.changes.outputs.api == 'true') ||
      (matrix.service == 'frontend' && needs.changes.outputs.frontend == 'true') ||
      (matrix.service == 'bot' && needs.changes.outputs.bot == 'true')

    steps:
      - uses: actions/checkout@v4

      - name: Compute SHORT_SHA
        run: echo "SHORT_SHA=${GITHUB_SHA::7}" >> "$GITHUB_ENV"

      - name: Log-in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push image
        run: ./build-target.sh

  # --------------------------------------------------
  # 2. Assemble & push the multi-arch manifests
  # --------------------------------------------------
  manifest:
    name: push ${{ matrix.service }} manifest
    needs: image # automatically skipped if image was skipped
    runs-on: ubuntu-latest
    container: ghcr.io/oras-project/oras:v1.2.2
    strategy:
      matrix:
        service: [api, frontend, bot]
    env:
      SERVICE: ${{ matrix.service }}

    steps:
      - name: Install prerequisites (git & node)
        run: |
          apk add --no-cache git nodejs npm bash
      - uses: actions/checkout@v4
      # Native ORAS login – token piped over stdin
      - name: Log in to GHCR with ORAS
        run:
          echo "${{ secrets.GITHUB_TOKEN }}" | \ oras login ${{ env.REGISTRY }} -u ${{ github.actor
          }} --password-stdin
          # --password-stdin keeps the token out of logs :contentReference[oaicite:2]{index=2}

      - name: Push manifest list
        run: ./manifest.sh
